<?xml version="1.0" encoding="UTF-8"?><w:document xmlns:w="http://schemas.openxmlformats.org/wordprocessingml/2006/main"><w:body><w:p><w:pPr><w:pStyle w:val="title"/><w:jc w:val="center"/></w:pPr><w:r><w:rPr><w:b/><w:u/></w:rPr><w:t>Didacticiel Matlab</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t></w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t>Ce didacticiel aborde la plupart des fonctionnalités utilisées dans les TP de Matlab, notamment pour les TP de Probabilités, Statistiques, Automatique, EDP et Optimisation du semestre 7. </w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t>Vous pouvez exécuter les blocs de texte et de code un par un en allant dans </w:t></w:r><w:r><w:rPr><w:b/></w:rPr><w:t>Run Section </w:t></w:r><w:customXml w:element="image"><w:customXmlPr><w:attr w:name="height" w:val="21"/><w:attr w:name="width" w:val="71"/><w:attr w:name="relationshipId" w:val="rId1"/></w:customXmlPr></w:customXml><w:r><w:t> (ou </w:t></w:r><w:r><w:rPr><w:b/></w:rPr><w:t>Run and Advance</w:t></w:r><w:r><w:t> </w:t></w:r><w:customXml w:element="image"><w:customXmlPr><w:attr w:name="height" w:val="21"/><w:attr w:name="width" w:val="93"/><w:attr w:name="relationshipId" w:val="rId2"/></w:customXmlPr></w:customXml><w:r><w:t> pour passer à la section suivante) en prenant le temps de bien les comprendre.</w:t></w:r></w:p><w:p><w:pPr><w:sectPr/></w:pPr></w:p><w:p><w:pPr><w:pStyle w:val="title"/><w:jc w:val="left"/></w:pPr><w:r><w:t></w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="title"/><w:jc w:val="left"/></w:pPr><w:r><w:t>1) Définition de matrices</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t></w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t>Pour définir un </w:t></w:r><w:r><w:rPr><w:b/></w:rPr><w:t>vecteur ligne</w:t></w:r><w:r><w:t> :</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="code"/></w:pPr><w:r><w:t><![CDATA[V_ligne = [1 3 5 7 9]]]></w:t></w:r></w:p><w:p><w:pPr><w:sectPr/></w:pPr></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t>Pour définir un </w:t></w:r><w:r><w:rPr><w:b/></w:rPr><w:t>vecteur colonne</w:t></w:r><w:r><w:t> :</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="code"/></w:pPr><w:r><w:t><![CDATA[V_colonne = [2; 4; 6; 8; 10]]]></w:t></w:r></w:p><w:p><w:pPr><w:sectPr/></w:pPr></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t>De manière générale, on utilise </w:t></w:r><w:r><w:rPr><w:b/></w:rPr><w:t>des espaces (ou des virgules) comme séparateur horizontal</w:t></w:r><w:r><w:t> et le </w:t></w:r><w:r><w:rPr><w:b/></w:rPr><w:t>point virgule comme séparateur vertical</w:t></w:r><w:r><w:t>. La même règle s'applique à la définition d'une matrice. Essayez de prédire la matrice qui sera définie par l'instruction suivante avant de l'exécuter :</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="code"/></w:pPr><w:r><w:t><![CDATA[M = [1 3 5 7 9; 2 4 6 8 10]]]></w:t></w:r></w:p><w:p><w:pPr><w:sectPr/></w:pPr></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t>On peut également construire </w:t></w:r><w:r><w:rPr><w:b/><w:rFonts w:cs="monospace"/></w:rPr><w:t>M</w:t></w:r><w:r><w:t> à partir de la </w:t></w:r><w:r><w:rPr><w:b/></w:rPr><w:t>concaténation</w:t></w:r><w:r><w:t> des vecteurs définis précédemment. On pourrait penser à écrire quelque chose comme :</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="code"/></w:pPr><w:r><w:t><![CDATA[M = [V_ligne; V_colonne]]]></w:t></w:r></w:p><w:p><w:pPr><w:sectPr/></w:pPr></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t>À l'exécution de cette ligne, une erreur de dimensions est levée. En effet, </w:t></w:r><w:r><w:rPr><w:b/><w:rFonts w:cs="monospace"/></w:rPr><w:t>V_ligne</w:t></w:r><w:r><w:t> est de taille 1x5 et </w:t></w:r><w:r><w:rPr><w:b/><w:rFonts w:cs="monospace"/></w:rPr><w:t>V_colonne</w:t></w:r><w:r><w:t> est de taille 5x1. En transposant </w:t></w:r><w:r><w:rPr><w:b/><w:rFonts w:cs="monospace"/></w:rPr><w:t>V_colonne</w:t></w:r><w:r><w:t> (</w:t></w:r><w:r><w:rPr><w:b/><w:rFonts w:cs="monospace"/></w:rPr><w:t>V_colonne</w:t></w:r><w:r><w:rPr><w:b/></w:rPr><w:t>'</w:t></w:r><w:r><w:t> ou </w:t></w:r><w:r><w:rPr><w:b/><w:rFonts w:cs="monospace"/></w:rPr><w:t>transpose(V_colonne)</w:t></w:r><w:r><w:t>), on résout ce problème de dimensions :</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="code"/></w:pPr><w:r><w:t><![CDATA[M = [V_ligne; V_colonne']]]></w:t></w:r></w:p><w:p><w:pPr><w:sectPr/></w:pPr></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t>Comme les valeurs de </w:t></w:r><w:r><w:rPr><w:b/><w:rFonts w:cs="monospace"/></w:rPr><w:t>M</w:t></w:r><w:r><w:t> sont régulièrement espacées, il est possible d'utiliser des </w:t></w:r><w:r><w:rPr><w:b/></w:rPr><w:t>plages de valeurs</w:t></w:r><w:r><w:t> avec un certain pas. Exécutez les deux instructions suivantes et identifiez à chaque fois les bornes de la plage ainsi que le pas.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="code"/></w:pPr><w:r><w:t><![CDATA[Enum1 = 3:7:90]]></w:t></w:r></w:p><w:p><w:pPr><w:sectPr/></w:pPr></w:p><w:p><w:pPr><w:pStyle w:val="code"/></w:pPr><w:r><w:t><![CDATA[Enum2 = 5:3:20]]></w:t></w:r></w:p><w:p><w:pPr><w:sectPr/></w:pPr></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:rPr><w:b/><w:i/></w:rPr><w:t>-------- Exercice</w:t></w:r><w:r><w:t> - Essayez de réécrire </w:t></w:r><w:r><w:rPr><w:b/><w:rFonts w:cs="monospace"/></w:rPr><w:t>V_ligne</w:t></w:r><w:r><w:t>, </w:t></w:r><w:r><w:rPr><w:b/><w:rFonts w:cs="monospace"/></w:rPr><w:t>V_colonne</w:t></w:r><w:r><w:t> et </w:t></w:r><w:r><w:rPr><w:b/><w:rFonts w:cs="monospace"/></w:rPr><w:t>M</w:t></w:r><w:r><w:t> en utilisant des plages.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="code"/></w:pPr><w:r><w:t><![CDATA[V_ligne = 0 % A modifier]]></w:t></w:r></w:p><w:p><w:pPr><w:sectPr/></w:pPr></w:p><w:p><w:pPr><w:pStyle w:val="code"/></w:pPr><w:r><w:t><![CDATA[V_colonne = 0 % A modifier]]></w:t></w:r></w:p><w:p><w:pPr><w:sectPr/></w:pPr></w:p><w:p><w:pPr><w:pStyle w:val="code"/></w:pPr><w:r><w:t><![CDATA[M = 0 % A modifier]]></w:t></w:r></w:p><w:p><w:pPr><w:sectPr/></w:pPr></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:rPr><w:b/></w:rPr><w:t>Attention à ne pas écrire </w:t></w:r><w:r><w:rPr><w:b/><w:rFonts w:cs="monospace"/></w:rPr><w:t>V_colonne = 2:2:10'</w:t></w:r><w:r><w:t> car la transposition ne s'applique alors qu'à 10 et on obtiendrait un vecteur ligne.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t>Enfin, il est possible de définir des matrices ne contenant que des 0 ou que des 1, ou encore des matrices identités (des 1 sur la diagonale et des 0 partout ailleurs). Dans tous ces cas, il faut indiquer les dimensions de la matrice souhaitée. Si une seule dimension est donnée, elle est utilisée comme nombre de lignes et de colonnes : on obtient alors une matrice carrée.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="code"/></w:pPr><w:r><w:t><![CDATA[M0 = zeros(3,5)]]></w:t></w:r></w:p><w:p><w:pPr><w:sectPr/></w:pPr></w:p><w:p><w:pPr><w:pStyle w:val="code"/></w:pPr><w:r><w:t><![CDATA[M1 = ones(3,5)]]></w:t></w:r></w:p><w:p><w:pPr><w:sectPr/></w:pPr></w:p><w:p><w:pPr><w:pStyle w:val="code"/></w:pPr><w:r><w:t><![CDATA[M2 = ones(4,4)]]></w:t></w:r></w:p><w:p><w:pPr><w:sectPr/></w:pPr></w:p><w:p><w:pPr><w:pStyle w:val="code"/></w:pPr><w:r><w:t><![CDATA[M3 = ones(4)]]></w:t></w:r></w:p><w:p><w:pPr><w:sectPr/></w:pPr></w:p><w:p><w:pPr><w:pStyle w:val="code"/></w:pPr><w:r><w:t><![CDATA[Id = eye(4)]]></w:t></w:r></w:p><w:p><w:pPr><w:sectPr/></w:pPr></w:p><w:p><w:pPr><w:pStyle w:val="title"/><w:jc w:val="left"/></w:pPr><w:r><w:t></w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="title"/><w:jc w:val="left"/></w:pPr><w:r><w:t>2) Opérations sur les matrices</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t></w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t>Il est possible d'ajouter une constante à un vecteur/une matrice :</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="code"/></w:pPr><w:r><w:t><![CDATA[MplusTrois = M+3]]></w:t></w:r></w:p><w:p><w:pPr><w:sectPr/></w:pPr></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t>Il est possible de multiplier un vecteur/une matrice par une constante :</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="code"/></w:pPr><w:r><w:t><![CDATA[troisFoisM = 3*M]]></w:t></w:r></w:p><w:p><w:pPr><w:sectPr/></w:pPr></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t>Il est possible d'additionner des matrices de mêmes tailles</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="code"/></w:pPr><w:r><w:t><![CDATA[MplusMplusM = M+M+M]]></w:t></w:r></w:p><w:p><w:pPr><w:sectPr/></w:pPr></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t>Attention, sous certaines conditions, Matlab permet les additions entre une matrice et un vecteur s'ils ont une dimension en commun. Le vecteur est alors répliqué selon la dimension non commune pour faire la même taille que la matrice. Par exemple, les deux instructions suivantes sont équivalentes :</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="code"/></w:pPr><w:r><w:t><![CDATA[M + [1 3 5 7 9]]]></w:t></w:r></w:p><w:p><w:pPr><w:sectPr/></w:pPr></w:p><w:p><w:pPr><w:pStyle w:val="code"/></w:pPr><w:r><w:t><![CDATA[M + [1 3 5 7 9; 1 3 5 7 9]]]></w:t></w:r></w:p><w:p><w:pPr><w:sectPr/></w:pPr></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:rPr><w:b/><w:rFonts w:cs="monospace"/></w:rPr><w:t>M</w:t></w:r><w:r><w:t> est de taille (2,5) et</w:t></w:r><w:r><w:rPr><w:b/><w:rFonts w:cs="monospace"/></w:rPr><w:t> V_ligne = [1 3 5 7 9]</w:t></w:r><w:r><w:t> est de taille (1,5) donc, lors de l'addition, </w:t></w:r><w:r><w:rPr><w:b/><w:rFonts w:cs="monospace"/></w:rPr><w:t>V_ligne</w:t></w:r><w:r><w:t> est répliqué deux fois pour faire la taille de </w:t></w:r><w:r><w:rPr><w:b/><w:rFonts w:cs="monospace"/></w:rPr><w:t>M</w:t></w:r><w:r><w:t>. Il est risqué d'utiliser cette réplication implicite propre à Matlab et nous verrons plus loin comment répliquer manuellement un vecteur ou une matrice.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t>Le produit matriciel usuel entre une matrice </w:t></w:r><w:r><w:rPr><w:b/><w:rFonts w:cs="monospace"/></w:rPr><w:t>M1</w:t></w:r><w:r><w:t> de taille (m,k) et une autre matrice </w:t></w:r><w:r><w:rPr><w:b/><w:rFonts w:cs="monospace"/></w:rPr><w:t>M2</w:t></w:r><w:r><w:t> de taille (k,n) donne une matrice de taille (m,n). Il se fait comme suit :</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="code"/></w:pPr><w:r><w:t><![CDATA[M*V_colonne]]></w:t></w:r></w:p><w:p><w:pPr><w:sectPr/></w:pPr></w:p><w:p><w:pPr><w:pStyle w:val="code"/></w:pPr><w:r><w:t><![CDATA[V_ligne*V_colonne]]></w:t></w:r></w:p><w:p><w:pPr><w:sectPr/></w:pPr></w:p><w:p><w:pPr><w:pStyle w:val="code"/></w:pPr><w:r><w:t><![CDATA[V_colonne*V_ligne]]></w:t></w:r></w:p><w:p><w:pPr><w:sectPr/></w:pPr></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t>Il est alors possible de répliquer un vecteur en le multipliant par un vecteur </w:t></w:r><w:r><w:rPr><w:b/><w:rFonts w:cs="monospace"/></w:rPr><w:t>ones</w:t></w:r><w:r><w:t> de taille adaptée. Par exemple, pour répliquer </w:t></w:r><w:r><w:rPr><w:b/><w:rFonts w:cs="monospace"/></w:rPr><w:t>[1 3 5 7 9]</w:t></w:r><w:r><w:t> de taille (1,5) en </w:t></w:r><w:r><w:rPr><w:b/><w:rFonts w:cs="monospace"/></w:rPr><w:t>[1 3 5 7 9; 1 3 5 7 9]</w:t></w:r><w:r><w:t> de taille (2,5), on peut faire l'instruction suivante :</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="code"/></w:pPr><w:r><w:t><![CDATA[ones(2,1) * [1 3 5 7 9]]]></w:t></w:r></w:p><w:p><w:pPr><w:sectPr/></w:pPr></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t>Enfin, il existe la fonction </w:t></w:r><w:r><w:rPr><w:b/><w:rFonts w:cs="monospace"/></w:rPr><w:t>repmat</w:t></w:r><w:r><w:t> (pour réplique matrice) qui permet de répliquer une matrice un certain nombre de fois horizontalement et/ou verticalement pour obtenir une plus grande matrice. Par exemple :</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="code"/></w:pPr><w:r><w:t><![CDATA[repmat(M, 4, 2)]]></w:t></w:r></w:p><w:p><w:pPr><w:sectPr/></w:pPr></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t>Ainsi, pour répliquer </w:t></w:r><w:r><w:rPr><w:b/><w:rFonts w:cs="monospace"/></w:rPr><w:t>[1 3 5 7 9]</w:t></w:r><w:r><w:t> en une matrice de tailles (2,5), on peut faire :</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="code"/></w:pPr><w:r><w:t><![CDATA[repmat([1 3 5 7 9], 2, 1)]]></w:t></w:r></w:p><w:p><w:pPr><w:sectPr/></w:pPr></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t>Il est possible de vectoriser une matrice. Le vecteur obtenu est </w:t></w:r><w:r><w:rPr><w:b/></w:rPr><w:t>la concaténation des colonnes</w:t></w:r><w:r><w:t> de la matrice dans une seule et même colonne.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="code"/></w:pPr><w:r><w:t><![CDATA[M_vectorise = M(:)]]></w:t></w:r></w:p><w:p><w:pPr><w:sectPr/></w:pPr></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t>Sur des matrices de mêmes tailles, il est possible d'effectuer des </w:t></w:r><w:r><w:rPr><w:b/></w:rPr><w:t>opérations élément par élément</w:t></w:r><w:r><w:t>, comme suit :</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="code"/></w:pPr><w:r><w:t><![CDATA[I = [200 180 170 190 155; 205 190 195 165 150; 210 215 175 155 190]
Coefficients = [0.5 0.2 0.4 0.8 1; 0.4 0.2 0 1 0.9; 0.75 0.5 0.6 1 0.1]
I.*Coefficients % Produit élément par élément de I et de Coefficients]]></w:t></w:r></w:p><w:p><w:pPr><w:sectPr/></w:pPr></w:p><w:p><w:pPr><w:pStyle w:val="code"/></w:pPr><w:r><w:t><![CDATA[I.*I % Matrice des carrés des éléments de I]]></w:t></w:r></w:p><w:p><w:pPr><w:sectPr/></w:pPr></w:p><w:p><w:pPr><w:pStyle w:val="code"/></w:pPr><w:r><w:t><![CDATA[I.^3 % Matrice de chaque élément de I élevé à la puissance 3]]></w:t></w:r></w:p><w:p><w:pPr><w:sectPr/></w:pPr></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t>Certaines fonctions s'effectuent sur tous les éléments d'une matrice sans qu'il soit nécessaire de le préciser avec un ".". C'est notamment le cas des fonctions usuelles cosinus </w:t></w:r><w:r><w:rPr><w:b/><w:rFonts w:cs="monospace"/></w:rPr><w:t>cos</w:t></w:r><w:r><w:t>, sinus </w:t></w:r><w:r><w:rPr><w:b/><w:rFonts w:cs="monospace"/></w:rPr><w:t>sin</w:t></w:r><w:r><w:t>, racine carrée </w:t></w:r><w:r><w:rPr><w:b/><w:rFonts w:cs="monospace"/></w:rPr><w:t>sqrt</w:t></w:r><w:r><w:t>, etc :</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="code"/></w:pPr><w:r><w:t><![CDATA[racineI = sqrt(I)]]></w:t></w:r></w:p><w:p><w:pPr><w:sectPr/></w:pPr></w:p><w:p><w:pPr><w:pStyle w:val="code"/></w:pPr><w:r><w:t><![CDATA[I - racineI.*racineI]]></w:t></w:r></w:p><w:p><w:pPr><w:sectPr/></w:pPr></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t>Dans cet exemple, on remarque que l'on obtient pas une matrice entièrement composée de 0 car la précision de la machine sur les opérations flottantes est limitée. Notez la présence du facteur multiplicatif 1.0e-13.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t></w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="title"/><w:jc w:val="left"/></w:pPr><w:r><w:t>3) Modification des éléments d'une matrice</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t></w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t>Lorsque l'on veut modifier la valeur d'un élément en particulier, une première syntaxe consiste à préciser le numéro de ligne et le numéro de colonne de l'élément :</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="code"/></w:pPr><w:r><w:t><![CDATA[Z1 = zeros(7, 5); % Ce point-virgule en fin de ligne permet de ne pas afficher le résultat de l'instruction
Z1(2, 3) = 4]]></w:t></w:r></w:p><w:p><w:pPr><w:sectPr/></w:pPr></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t>On remarque qu'en Matlab, les indices commencent à 1 et non à 0 comme dans de nombreux langages (C, Python...). Une deuxième syntaxe consiste à donner </w:t></w:r><w:r><w:rPr><w:b/></w:rPr><w:t>l'indice absolu</w:t></w:r><w:r><w:t> de l'élément. De nouveau, on compte selon les colonnes :</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="code"/></w:pPr><w:r><w:t><![CDATA[Z1(5) = 18]]></w:t></w:r></w:p><w:p><w:pPr><w:sectPr/></w:pPr></w:p><w:p><w:pPr><w:pStyle w:val="code"/></w:pPr><w:r><w:t><![CDATA[Z1(13) = 21]]></w:t></w:r></w:p><w:p><w:pPr><w:sectPr/></w:pPr></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t>Il existe deux fonctions </w:t></w:r><w:r><w:rPr><w:b/><w:rFonts w:cs="monospace"/></w:rPr><w:t>sub2ind</w:t></w:r><w:r><w:t> et </w:t></w:r><w:r><w:rPr><w:b/><w:rFonts w:cs="monospace"/></w:rPr><w:t>ind2sub</w:t></w:r><w:r><w:t> qui permettent de convertir un indice absolu en indices relatifs (numéros de ligne et de colonne) et inversement. Il est nécessaire de donner la taille de la matrice considérée en entrée de ces fonctions :</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="code"/></w:pPr><w:r><w:t><![CDATA[[ligne, colonne] = ind2sub(size(Z1), 13)
indice_absolu = sub2ind(size(Z1), 2, 4)]]></w:t></w:r></w:p><w:p><w:pPr><w:sectPr/></w:pPr></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t>La fonction </w:t></w:r><w:r><w:rPr><w:b/><w:rFonts w:cs="monospace"/></w:rPr><w:t>ind2sub</w:t></w:r><w:r><w:t> est une fonction qui peut renvoyer plusieurs sorties : elle renvoie l'indice de ligne et l'indice de colonne. Nous donnerons d'autres exemples de ce genre de fonctions plus loin.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t>Pour modifier plusieurs éléments simultanément, il faut indiquer les indices des éléments à modifier et donner les nouvelles valeurs de ces éléments dans une matrice de taille adaptée. Nous donnons plusieurs exemples ci-dessous, prenez le temps de les comprendre :</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="code"/></w:pPr><w:r><w:t><![CDATA[Z2 = zeros(9, 7);
Z2(2, 3:7) = V_ligne]]></w:t></w:r></w:p><w:p><w:pPr><w:sectPr/></w:pPr></w:p><w:p><w:pPr><w:pStyle w:val="code"/></w:pPr><w:r><w:t><![CDATA[Z2(4:8, 1) = V_colonne]]></w:t></w:r></w:p><w:p><w:pPr><w:sectPr/></w:pPr></w:p><w:p><w:pPr><w:pStyle w:val="code"/></w:pPr><w:r><w:t><![CDATA[Z2(5:6, 3:7) = M]]></w:t></w:r></w:p><w:p><w:pPr><w:sectPr/></w:pPr></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t>Il est possible d'extraire une sous-matrice en indiquant les plages d'indices désirées. Par exemple :</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="code"/></w:pPr><w:r><w:t><![CDATA[Z2(3:8, 1:5)]]></w:t></w:r></w:p><w:p><w:pPr><w:sectPr/></w:pPr></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t>On peut également indiquer un pas. Essayez de prédire ce que renvoie l'instruction suivante puis exécutez-la :</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="code"/></w:pPr><w:r><w:t><![CDATA[Z2(2:2:6, 3:2:7)]]></w:t></w:r></w:p><w:p><w:pPr><w:sectPr/></w:pPr></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t>La sous-matrice obtenue est de taille (3,3). Il est donc possible de modifier tous ces éléments d'un coup en donnant les nouvelles valeurs dans une matrice de taille (3,3), comme dans l'exemple suivant. Prenez le temps de bien localiser les éléments de </w:t></w:r><w:r><w:rPr><w:b/><w:rFonts w:cs="monospace"/></w:rPr><w:t>A</w:t></w:r><w:r><w:t> dans la matrice </w:t></w:r><w:r><w:rPr><w:b/><w:rFonts w:cs="monospace"/></w:rPr><w:t>Z2</w:t></w:r><w:r><w:t> :</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="code"/></w:pPr><w:r><w:t><![CDATA[A = [3 4 2; 5 5 5; 9 0 3]
Z2(2:2:6, 3:2:7) = A]]></w:t></w:r></w:p><w:p><w:pPr><w:sectPr/></w:pPr></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t>La longueur d'un vecteur peut être obtenue par la fonction </w:t></w:r><w:r><w:rPr><w:b/><w:rFonts w:cs="monospace"/></w:rPr><w:t>length</w:t></w:r><w:r><w:t> :</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="code"/></w:pPr><w:r><w:t><![CDATA[longueur = length(V_ligne)]]></w:t></w:r></w:p><w:p><w:pPr><w:sectPr/></w:pPr></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t>L'utilisation de </w:t></w:r><w:r><w:rPr><w:b/><w:rFonts w:cs="monospace"/></w:rPr><w:t>length</w:t></w:r><w:r><w:t> sur une matrice est déconseillé car la fonction ne retourne alors que la plus grande dimension de la matrice. Le </w:t></w:r><w:r><w:rPr><w:b/></w:rPr><w:t>nombre de lignes</w:t></w:r><w:r><w:t> et le </w:t></w:r><w:r><w:rPr><w:b/></w:rPr><w:t>nombre de colonnes</w:t></w:r><w:r><w:t> d'une matrice peuvent être obtenus avec </w:t></w:r><w:r><w:rPr><w:b/><w:rFonts w:cs="monospace"/></w:rPr><w:t>size</w:t></w:r><w:r><w:t> en faisant :</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="code"/></w:pPr><w:r><w:t><![CDATA[Z3 = zeros(6, 4)
nb_lignes = size(Z3, 1)
nb_colonnes = size(Z3, 2)]]></w:t></w:r></w:p><w:p><w:pPr><w:sectPr/></w:pPr></w:p><w:p><w:pPr><w:pStyle w:val="code"/></w:pPr><w:r><w:t><![CDATA[[nb_lignes,nb_colonnes] = size(Z3)
plus_grande_dimension = length(Z3)]]></w:t></w:r></w:p><w:p><w:pPr><w:sectPr/></w:pPr></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t>Il existe plusieurs façons de redéfinir une ligne (ou une colonne) entière. On peut donner une plage d'indices allant de 1 à </w:t></w:r><w:r><w:rPr><w:b/><w:rFonts w:cs="monospace"/></w:rPr><w:t>nb_lignes</w:t></w:r><w:r><w:t> ou </w:t></w:r><w:r><w:rPr><w:b/><w:rFonts w:cs="monospace"/></w:rPr><w:t>nb_colonnes</w:t></w:r><w:r><w:t> :</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="code"/></w:pPr><w:r><w:t><![CDATA[Z3(4, 1:nb_colonnes) = 99
Z3(1:nb_lignes, 2) = -55]]></w:t></w:r></w:p><w:p><w:pPr><w:sectPr/></w:pPr></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t>On peut utiliser le symbole "</w:t></w:r><w:r><w:rPr><w:b/><w:rFonts w:cs="monospace"/></w:rPr><w:t>:</w:t></w:r><w:r><w:t>" qui indique de considérer tous les éléments de la ligne (ou de la colonne) :</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="code"/></w:pPr><w:r><w:t><![CDATA[Z4 = zeros(6, 4)
Z4(3, :) = 11
Z4(:, 4) = -33]]></w:t></w:r></w:p><w:p><w:pPr><w:sectPr/></w:pPr></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t>Enfin, il est possible d'utiliser le mot clé </w:t></w:r><w:r><w:rPr><w:b/><w:rFonts w:cs="monospace"/></w:rPr><w:t>end</w:t></w:r><w:r><w:t> à la place de </w:t></w:r><w:r><w:rPr><w:b/><w:rFonts w:cs="monospace"/></w:rPr><w:t>nb_lignes</w:t></w:r><w:r><w:t> ou </w:t></w:r><w:r><w:rPr><w:b/><w:rFonts w:cs="monospace"/></w:rPr><w:t>nb_colonnes</w:t></w:r><w:r><w:t> pour aller au bout d'une dimension :</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="code"/></w:pPr><w:r><w:t><![CDATA[Z5 = zeros(6, 4)
Z5(2, 1:end) = 222
Z5(1:end, 1) = 666]]></w:t></w:r></w:p><w:p><w:pPr><w:sectPr/></w:pPr></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t>Pour modifier simultanément plusieurs éléments, on utilise un vecteur d'indices absolus. Par exemple, pour mettre la valeur 1 aux indices absolus </w:t></w:r><w:r><w:rPr><w:b/><w:rFonts w:cs="monospace"/></w:rPr><w:t>2, 5, 7, 12, 13, 14, 19</w:t></w:r><w:r><w:t> d'une matrice de taille (6,4), on utilise :</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="code"/></w:pPr><w:r><w:t><![CDATA[Z6 = zeros(6, 4)
Z6([2, 5, 7, 12, 13, 14, 19]) = 1]]></w:t></w:r></w:p><w:p><w:pPr><w:sectPr/></w:pPr></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t>La fonction </w:t></w:r><w:r><w:rPr><w:b/><w:rFonts w:cs="monospace"/></w:rPr><w:t>sub2ind</w:t></w:r><w:r><w:t> évoquée précédemment peut s'avérer utile pour récupérer un indice absolu à partir des numéros de ligne et de colonne d'un élément. En pratique, on n'utilise rarement ces conversions car Matlab dispose de fonctions qui permettent de s'en passer. Nous donnons un exemple ci-dessous.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t>Supposons que l'on dispose d'une matrice I et que l'on souhaite remplacer tous les éléments de </w:t></w:r><w:r><w:rPr><w:b/><w:rFonts w:cs="monospace"/></w:rPr><w:t>I</w:t></w:r><w:r><w:t> de valeur inférieure à un certain seuil (disons 177) par 0. L'instruction </w:t></w:r><w:r><w:rPr><w:b/><w:rFonts w:cs="monospace"/></w:rPr><w:t>I &lt;= 177</w:t></w:r><w:r><w:t> renvoie une matrice booléenne :</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="code"/></w:pPr><w:r><w:t><![CDATA[I = [200 180 170 190 155; 205 190 195 165 150; 210 215 175 155 190]
I <= 177]]></w:t></w:r></w:p><w:p><w:pPr><w:sectPr/></w:pPr></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t>Pour récupérer les indices des valeurs de </w:t></w:r><w:r><w:rPr><w:b/><w:rFonts w:cs="monospace"/></w:rPr><w:t>I</w:t></w:r><w:r><w:t> inférieures à 177 avec </w:t></w:r><w:r><w:rPr><w:b/><w:rFonts w:cs="monospace"/></w:rPr><w:t>find</w:t></w:r><w:r><w:t> :</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="code"/></w:pPr><w:r><w:t><![CDATA[find(I <= 177)]]></w:t></w:r></w:p><w:p><w:pPr><w:sectPr/></w:pPr></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t>On peut alors récupérer les éléments de </w:t></w:r><w:r><w:rPr><w:b/><w:rFonts w:cs="monospace"/></w:rPr><w:t>I</w:t></w:r><w:r><w:t> inférieurs à 177 en faisant :</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="code"/></w:pPr><w:r><w:t><![CDATA[I(find(I <= 177))]]></w:t></w:r></w:p><w:p><w:pPr><w:sectPr/></w:pPr></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t>L'instruction suivante, plus épurée et optimale (d'où le surlignage orange ci-dessus pour un avertissement d'optimalité du code), renvoie le même résultat :</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="code"/></w:pPr><w:r><w:t><![CDATA[I(I <= 177)]]></w:t></w:r></w:p><w:p><w:pPr><w:sectPr/></w:pPr></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t>Ainsi, pour mettre à 0 tous les éléments de I inférieures à 177, on peut écrire :</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="code"/></w:pPr><w:r><w:t><![CDATA[I(I <= 177) = 0]]></w:t></w:r></w:p><w:p><w:pPr><w:sectPr/></w:pPr></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t>Enfin, pour tester l'égalité entre deux matrices (ou vecteurs), on pourrait être tentés de faire :</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="code"/></w:pPr><w:r><w:t><![CDATA[A = [pi, 2*pi, 3*pi; 4*pi, 5*pi, 6*pi] 
B = [3.1416, 6.2832, 9.4248; 12.5664, 15.7080, 18.8496]
(A == B)]]></w:t></w:r></w:p><w:p><w:pPr><w:sectPr/></w:pPr></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t>Les valeurs affichées dans </w:t></w:r><w:r><w:rPr><w:b/><w:rFonts w:cs="monospace"/></w:rPr><w:t>A</w:t></w:r><w:r><w:t> et dans </w:t></w:r><w:r><w:rPr><w:b/><w:rFonts w:cs="monospace"/></w:rPr><w:t>B</w:t></w:r><w:r><w:t> sont les mêmes. Pourtant, la matrice de booléens </w:t></w:r><w:r><w:rPr><w:b/><w:rFonts w:cs="monospace"/></w:rPr><w:t>A == B</w:t></w:r><w:r><w:t> ne contient que des 0 (associés à la valeur "faux"). Deux problèmes entrent en jeu :</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="ListParagraph"/><w:numPr><w:numId w:val="1"/></w:numPr><w:jc w:val="left"/></w:pPr><w:r><w:t>d'une part, Matlab n'affiche qu'un certain nombre de décimales ;</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="ListParagraph"/><w:numPr><w:numId w:val="1"/></w:numPr><w:jc w:val="left"/></w:pPr><w:r><w:t>d'autre part, lorsque l'on manipule des nombres flottants, on manipule en vérité des valeurs à une précision machine près.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t>La façon standard de vérifier que deux flottants sont égaux consiste donc à vérifier que leur différence en valeur absolue est inférieur à un certain seuil de précision fixé par l'utilisateur en fonction du contexte. Par exemple :</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="code"/></w:pPr><w:r><w:t><![CDATA[abs(pi-3.1416) < 0.001
abs(pi-3.1416) < 0.000001]]></w:t></w:r></w:p><w:p><w:pPr><w:sectPr/></w:pPr></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t>De façon analogue, la vérification d'égalité entre deux matrices impliquera :</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="ListParagraph"/><w:numPr><w:numId w:val="1"/></w:numPr><w:jc w:val="left"/></w:pPr><w:r><w:t>de vérifier qu'elles ont la même taille (donc le même nombre de coefficients) ;</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="ListParagraph"/><w:numPr><w:numId w:val="1"/></w:numPr><w:jc w:val="left"/></w:pPr><w:r><w:t>que les différences en valeur absolue des coefficients terme à terme sont inférieures à un certain seuil.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t></w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="title"/><w:jc w:val="left"/></w:pPr><w:r><w:t>4) Fonctions utiles</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t></w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t>On peut modifier la forme d'une matrice avec la fonction </w:t></w:r><w:r><w:rPr><w:b/><w:rFonts w:cs="monospace"/></w:rPr><w:t>reshape</w:t></w:r><w:r><w:t> : la seule contrainte est que le nombre d'éléments total doit rester le même. À nouveau, l'ordre des éléments se retrouve dans la vectorisation de la matrice, comme illustré ci-dessous sur une matrice de taille (4,6) (donc à 24 éléments). Prenez le temps de bien comprendre les exemples ci-dessous :</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="code"/></w:pPr><w:r><w:t><![CDATA[J = [200 180 170 190 155 120; 205 190 195 165 150 60; 210 215 175 155 190 160; 125 155 165 145 200 185]
J1 = J(:) % Vectorisation de J]]></w:t></w:r></w:p><w:p><w:pPr><w:sectPr/></w:pPr></w:p><w:p><w:pPr><w:pStyle w:val="code"/></w:pPr><w:r><w:t><![CDATA[J2 = reshape(J, 3, 8)]]></w:t></w:r></w:p><w:p><w:pPr><w:sectPr/></w:pPr></w:p><w:p><w:pPr><w:pStyle w:val="code"/></w:pPr><w:r><w:t><![CDATA[J3 = reshape(J, 6, 4)]]></w:t></w:r></w:p><w:p><w:pPr><w:sectPr/></w:pPr></w:p><w:p><w:pPr><w:pStyle w:val="code"/></w:pPr><w:r><w:t><![CDATA[J4 = reshape(J, 8, 3)]]></w:t></w:r></w:p><w:p><w:pPr><w:sectPr/></w:pPr></w:p><w:p><w:pPr><w:pStyle w:val="code"/></w:pPr><w:r><w:t><![CDATA[J5 = reshape(J, 24, 1) % équivalent à J(:)]]></w:t></w:r></w:p><w:p><w:pPr><w:sectPr/></w:pPr></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t>La fonction </w:t></w:r><w:r><w:rPr><w:b/><w:rFonts w:cs="monospace"/></w:rPr><w:t>max</w:t></w:r><w:r><w:t> permet de récupérer l'élément d'un vecteur (colonne ou ligne) de valeur maximale, ainsi que son indice. Il s'agit d'une fonction qui peut renvoyer plusieurs sorties, tout comme </w:t></w:r><w:r><w:rPr><w:b/><w:rFonts w:cs="monospace"/></w:rPr><w:t>size</w:t></w:r><w:r><w:t>. Observez les deux syntaxes suivantes et identifiez les différences :</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="code"/></w:pPr><w:r><w:t><![CDATA[W = [4, 12, 3, 7, 6]
valeur_maximale = max(W)]]></w:t></w:r></w:p><w:p><w:pPr><w:sectPr/></w:pPr></w:p><w:p><w:pPr><w:pStyle w:val="code"/></w:pPr><w:r><w:t><![CDATA[[valeur_maximale, indice_du_maximum] = max(W)]]></w:t></w:r></w:p><w:p><w:pPr><w:sectPr/></w:pPr></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t>Si l'on ne précise qu'une seule sortie, </w:t></w:r><w:r><w:rPr><w:b/><w:rFonts w:cs="monospace"/></w:rPr><w:t>max</w:t></w:r><w:r><w:t> ne renvoie que la valeur maximale. Pour obtenir l'indice du maximum, il faut demander deux sorties entre crochets comme dans la deuxième syntaxe. Si l'on ne souhaite se servir que de l'indice du maximum, il est possible de se passer de la sortie correspondant à la valeur du maximum (la première donc) avec le symbole "</w:t></w:r><w:r><w:rPr><w:b/><w:rFonts w:cs="monospace"/></w:rPr><w:t>~</w:t></w:r><w:r><w:t>" :</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="code"/></w:pPr><w:r><w:t><![CDATA[[~, indice_du_maximum] = max(W)]]></w:t></w:r></w:p><w:p><w:pPr><w:sectPr/></w:pPr></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t>Dans le cas d'une matrice, la fonction </w:t></w:r><w:r><w:rPr><w:b/><w:rFonts w:cs="monospace"/></w:rPr><w:t>max</w:t></w:r><w:r><w:t> permet de récupérer la valeur maximale de chaque colonne ainsi que son indice.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="code"/></w:pPr><w:r><w:t><![CDATA[J
maxima = max(J)
[~, indices_maxima] = max(J)]]></w:t></w:r></w:p><w:p><w:pPr><w:sectPr/></w:pPr></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t>Si l'on souhaite récupérer les maxima (ou les indices) de chaque ligne et non plus de chaque colonne, il faut préciser la dimension à la fonction </w:t></w:r><w:r><w:rPr><w:b/></w:rPr><w:t>max</w:t></w:r><w:r><w:t> de la manière suivante :</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="code"/></w:pPr><w:r><w:t><![CDATA[J
maxima = max(J,[],2)
[~, indices_maxima] = max(J,[],2)]]></w:t></w:r></w:p><w:p><w:pPr><w:sectPr/></w:pPr></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t>De la même façon, la fonction </w:t></w:r><w:r><w:rPr><w:b/><w:rFonts w:cs="monospace"/></w:rPr><w:t>sort</w:t></w:r><w:r><w:t> permet de trier les valeurs par ordre croissant ('ascend') ou décroissant ('descend') et de renvoyer les indices correspondants si deux sorties sont demandées.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="code"/></w:pPr><w:r><w:t><![CDATA[valeurs_ordre_croissant = sort(W, 'ascend') % L'ordre est croissant par défaut si l'on ne précise pas dans la fonction
valeurs_ordre_decroissant = sort(W, 'descend')]]></w:t></w:r></w:p><w:p><w:pPr><w:sectPr/></w:pPr></w:p><w:p><w:pPr><w:pStyle w:val="code"/></w:pPr><w:r><w:t><![CDATA[[valeurs_ordre_croissant, indices_ordre_croissant] = sort(W, 'ascend')]]></w:t></w:r></w:p><w:p><w:pPr><w:sectPr/></w:pPr></w:p><w:p><w:pPr><w:pStyle w:val="code"/></w:pPr><w:r><w:t><![CDATA[[~, indices_ordre_croissant] = sort(W, 'ascend')]]></w:t></w:r></w:p><w:p><w:pPr><w:sectPr/></w:pPr></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t>On peut vérifier que </w:t></w:r><w:r><w:rPr><w:b/><w:rFonts w:cs="monospace"/></w:rPr><w:t>W(indices_ordre_croissant)</w:t></w:r><w:r><w:t> donne </w:t></w:r><w:r><w:rPr><w:b/><w:rFonts w:cs="monospace"/></w:rPr><w:t>valeurs_ordre_croissant</w:t></w:r><w:r><w:t> :</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="code"/></w:pPr><w:r><w:t><![CDATA[W(indices_ordre_croissant)
valeurs_ordre_croissant]]></w:t></w:r></w:p><w:p><w:pPr><w:sectPr/></w:pPr></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t>La fonction</w:t></w:r><w:r><w:t> </w:t></w:r><w:r><w:rPr><w:b/><w:rFonts w:cs="monospace"/></w:rPr><w:t>mean</w:t></w:r><w:r><w:t> </w:t></w:r><w:r><w:t>renvoie :</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="ListParagraph"/><w:numPr><w:numId w:val="1"/></w:numPr><w:jc w:val="left"/></w:pPr><w:r><w:t>la moyenne des éléments d'un vecteur lorsqu'elle est utilisée sur un vecteur ;</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="ListParagraph"/><w:numPr><w:numId w:val="1"/></w:numPr><w:jc w:val="left"/></w:pPr><w:r><w:t>les moyennes de chaque colonne ou de chaque ligne d'une matrice lorsqu'elle est utilisée sur une matrice.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t>Pour préciser si la moyenne doit être calculée par lignes ou par colonnes, il est nécessaire d'ajouter un deuxième argument égal à 1 (par colonnes) ou à 2 (par lignes). Par défaut, en l'absence de deuxième argument, la moyenne est calculée par colonnes (valeur par défaut : 1).</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="code"/></w:pPr><w:r><w:t><![CDATA[V = [2 3 5 8 12]
mean(V)]]></w:t></w:r></w:p><w:p><w:pPr><w:sectPr/></w:pPr></w:p><w:p><w:pPr><w:pStyle w:val="code"/></w:pPr><w:r><w:t><![CDATA[M = [1 3 5 7 9; 2 4 6 8 10]
moyennes_par_colonnes = mean(M, 1)
moyennes_par_lignes = mean(M, 2)
moyennes_par_defaut = mean(M)]]></w:t></w:r></w:p><w:p><w:pPr><w:sectPr/></w:pPr></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t>De façon similaire, la fonction</w:t></w:r><w:r><w:t> </w:t></w:r><w:r><w:rPr><w:b/><w:rFonts w:cs="monospace"/></w:rPr><w:t>sum</w:t></w:r><w:r><w:t> </w:t></w:r><w:r><w:t>renvoie :</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="ListParagraph"/><w:numPr><w:numId w:val="1"/></w:numPr><w:jc w:val="left"/></w:pPr><w:r><w:t>la somme des éléments d'un vecteur lorsqu'elle est utilisée sur un vecteur ;</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="ListParagraph"/><w:numPr><w:numId w:val="1"/></w:numPr><w:jc w:val="left"/></w:pPr><w:r><w:t>les sommes de chaque colonne ou de chaque ligne d'une matrice lorsqu'elle est utilisée sur une matrice. De nouveau, pour préciser si les moyennes doivent être calculées par lignes ou par colonnes, on ajoute un deuxième argument égal à 1 (par colonnes) ou à 2 (par lignes). Par défaut, si l'on n'indique pas de deuxième argument, il est égal à 1.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="code"/></w:pPr><w:r><w:t><![CDATA[V = [2 3 5 8 12]
sum(V)]]></w:t></w:r></w:p><w:p><w:pPr><w:sectPr/></w:pPr></w:p><w:p><w:pPr><w:pStyle w:val="code"/></w:pPr><w:r><w:t><![CDATA[M = [1 3 5 7 9; 2 4 6 8 10]
sommes_par_colonnes = sum(M, 1)
sommes_par_lignes = sum(M, 2)
sommes_par_defaut = sum(M)]]></w:t></w:r></w:p><w:p><w:pPr><w:sectPr/></w:pPr></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t>Ainsi, les moyennes peuvent être calculées soit avec </w:t></w:r><w:r><w:rPr><w:b/><w:rFonts w:cs="monospace"/></w:rPr><w:t>mean</w:t></w:r><w:r><w:t>, soit avec </w:t></w:r><w:r><w:rPr><w:b/><w:rFonts w:cs="monospace"/></w:rPr><w:t>sum</w:t></w:r><w:r><w:t> et </w:t></w:r><w:r><w:rPr><w:b/><w:rFonts w:cs="monospace"/></w:rPr><w:t>size</w:t></w:r><w:r><w:t>.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="code"/></w:pPr><w:r><w:t><![CDATA[M = [1 3 5 7 9; 2 4 6 8 10];
mean(M, 1)
sum(M, 1)/size(M, 1)
mean(M, 2)
sum(M, 2)/size(M, 2)]]></w:t></w:r></w:p><w:p><w:pPr><w:sectPr/></w:pPr></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t>Enfin, il est possible de consulter la document d'une fonction avec la commande </w:t></w:r><w:r><w:rPr><w:b/><w:rFonts w:cs="monospace"/></w:rPr><w:t>help</w:t></w:r><w:r><w:t> ou en tapant dans </w:t></w:r><w:r><w:rPr><w:i/></w:rPr><w:t>Search Documentation </w:t></w:r><w:r><w:t>situé en haut à droite dans Matlab. Des exemples numériques sont notamment donnés en fin de documentation :</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="code"/></w:pPr><w:r><w:t><![CDATA[help sum]]></w:t></w:r></w:p><w:p><w:pPr><w:sectPr/></w:pPr></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t></w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="title"/><w:jc w:val="left"/></w:pPr><w:r><w:t>5) Définir une fonction</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t></w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t>Il est possible de définir des fonctions en donnant ses paramètres d'entrée et de sortie. L'idée est avant tout de voir la syntaxe d'une défintion de fonction. Pour ce faire, chaque fonction Matlab est écrite dans un fichier à part portant le nom de la fonction en question.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t>Par exemple, si l'on veut définir une fonction appelée </w:t></w:r><w:r><w:rPr><w:b/><w:rFonts w:cs="monospace"/></w:rPr><w:t>calculs_basiques</w:t></w:r><w:r><w:t> qui, à partir de deux entrées </w:t></w:r><w:r><w:rPr><w:b/><w:rFonts w:cs="monospace"/></w:rPr><w:t>a</w:t></w:r><w:r><w:t> et </w:t></w:r><w:r><w:rPr><w:b/><w:rFonts w:cs="monospace"/></w:rPr><w:t>b</w:t></w:r><w:r><w:t> renvoie trois sorties contenant respectivement la somme, la différence et le produit de </w:t></w:r><w:r><w:rPr><w:b/><w:rFonts w:cs="monospace"/></w:rPr><w:t>a</w:t></w:r><w:r><w:t> et </w:t></w:r><w:r><w:rPr><w:b/><w:rFonts w:cs="monospace"/></w:rPr><w:t>b</w:t></w:r><w:r><w:t>, on ouvre le finchier </w:t></w:r><w:r><w:rPr><w:b/><w:rFonts w:cs="monospace"/></w:rPr><w:t>calculs_basiques.m </w:t></w:r><w:r><w:t>contenant le prototype de la fonction en question.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="code"/></w:pPr><w:r><w:t><![CDATA[resultats = calculs_basiques(3, 5)]]></w:t></w:r></w:p><w:p><w:pPr><w:sectPr/></w:pPr></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:rPr><w:b/><w:rFonts w:cs="monospace"/></w:rPr><w:t>resultats</w:t></w:r><w:r><w:t> sera égal à 8 car il ne contiendra que la première sortie de </w:t></w:r><w:r><w:rPr><w:b/><w:rFonts w:cs="monospace"/></w:rPr><w:t>calculs_basiques</w:t></w:r><w:r><w:t> (somme). On a déjà abordé ce point en présentant les fonctions </w:t></w:r><w:r><w:rPr><w:b/><w:rFonts w:cs="monospace"/></w:rPr><w:t>sort</w:t></w:r><w:r><w:t> et </w:t></w:r><w:r><w:rPr><w:b/><w:rFonts w:cs="monospace"/></w:rPr><w:t>max</w:t></w:r><w:r><w:t> : elles peuvent retourner plusieurs sorties mais ne retournent que la première d'entre elles si l'on ne précise pas avec des crochets les sorties désirées.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t>Si maintenant à l'inverse on crée une fonction </w:t></w:r><w:r><w:rPr><w:b/><w:rFonts w:cs="monospace"/></w:rPr><w:t>calculs_basiques_variante</w:t></w:r><w:r><w:t> (voir fichier de fonction du même nom) qui renvoie les 3 calculs sous forme de vecteur dans une seule variable de sortie, une erreur sera affichée par la ligne suivante car une seule sortie est attendue de la part de cette fonction.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="code"/></w:pPr><w:r><w:t><![CDATA[[somme, difference, produit] = calculs_basiques_variante(3, 5);]]></w:t></w:r></w:p><w:p><w:pPr><w:sectPr/></w:pPr></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t></w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="title"/><w:jc w:val="left"/></w:pPr><w:r><w:t>6) Les structures de contrôle</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t></w:t></w:r></w:p><w:p><mc:AlternateContent xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"><mc:Choice Requires="R2018b"><w:pPr><w:pStyle w:val="heading2"/><w:jc w:val="left"/></w:pPr></mc:Choice><mc:Fallback><w:pPr><w:pStyle w:val="heading"/><w:jc w:val="left"/></w:pPr></mc:Fallback></mc:AlternateContent><w:r><w:t>6.1) Les boucles for</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t></w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t>Lorsque l'on veut faire une boucle </w:t></w:r><w:r><w:rPr><w:b/><w:rFonts w:cs="monospace"/></w:rPr><w:t>for</w:t></w:r><w:r><w:t> en Matlab, on précise un vecteur contenant toutes les valeurs que doit prendre l'indice de boucle (i dans l'exemple donné ci-dessous). Par exemple, pour une boucle de 1 à 1000 on utilisera le vecteur [1 2 3 ... 1000] qui s'écrit plus simplement </w:t></w:r><w:r><w:rPr><w:b/><w:rFonts w:cs="monospace"/></w:rPr><w:t>1:1000</w:t></w:r><w:r><w:t>.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="code"/></w:pPr><w:r><w:t><![CDATA[somme = 0;
for i = 1:5
    somme = somme + i  % Ajouter un ';' en fin de ligne permet d'éviter l'affichage 
end]]></w:t></w:r></w:p><w:p><w:pPr><w:sectPr/></w:pPr></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t>Cet exemple illustre bien l'intérêt d'ajouter des "</w:t></w:r><w:r><w:rPr><w:b/><w:rFonts w:cs="monospace"/></w:rPr><w:t>;</w:t></w:r><w:r><w:t>" en fin de ligne pour éviter l'affichage.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t>Dans l'exemple suivant, nous souhaitons calculer une matrice C qui est la somme de deux matrices A et B. Nous montrons comment le faire de deux manières différentes :</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="ListParagraph"/><w:numPr><w:numId w:val="1"/></w:numPr><w:jc w:val="left"/></w:pPr><w:r><w:t>avec une boucle</w:t></w:r><w:r><w:t> </w:t></w:r><w:r><w:rPr><w:b/><w:rFonts w:cs="monospace"/></w:rPr><w:t>for</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="ListParagraph"/><w:numPr><w:numId w:val="1"/></w:numPr><w:jc w:val="left"/></w:pPr><w:r><w:t>matriciellement</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t>Pour chaque méthode, nous mesurons le temps d'exécution en appelant les instructions</w:t></w:r><w:r><w:t> </w:t></w:r><w:r><w:rPr><w:b/><w:rFonts w:cs="monospace"/></w:rPr><w:t>tic</w:t></w:r><w:r><w:t> </w:t></w:r><w:r><w:t>et</w:t></w:r><w:r><w:t> </w:t></w:r><w:r><w:rPr><w:b/><w:rFonts w:cs="monospace"/></w:rPr><w:t>toc</w:t></w:r><w:r><w:t> </w:t></w:r><w:r><w:t>respectivement avant et après le bloc de code dont on veut mesurer le temps d'exécution.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="code"/></w:pPr><w:r><w:t><![CDATA[A = rand(2000,1500);
B = rand(size(A));
C = zeros(size(A));

tic
% Avec une boucle for
for i = 1:size(C, 1)
    for j = 1:size(C, 2)
        C(i, j) = A(i, j) + B(i, j);
    end
end
toc]]></w:t></w:r></w:p><w:p><w:pPr><w:sectPr/></w:pPr></w:p><w:p><w:pPr><w:pStyle w:val="code"/></w:pPr><w:r><w:t><![CDATA[A = rand(2000, 1500);
B = rand(size(A));

tic
C = A + B;
toc]]></w:t></w:r></w:p><w:p><w:pPr><w:sectPr/></w:pPr></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t>Bien souvent, le fait d'utiliser des boucles</w:t></w:r><w:r><w:t> </w:t></w:r><w:r><w:rPr><w:b/><w:rFonts w:cs="monospace"/></w:rPr><w:t>for</w:t></w:r><w:r><w:t> </w:t></w:r><w:r><w:t>augmente les temps de calcul. Il n'est cependant pas toujours évident de se passer de ces boucles, mais nous vous demanderons de les éviter au maximum lorsqu'elles sont remplaçables par d'autres fonctions ou opérations matricielles.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t>Pour illustrer un cas où se passer de boucle</w:t></w:r><w:r><w:t> </w:t></w:r><w:r><w:rPr><w:b/><w:rFonts w:cs="monospace"/></w:rPr><w:t>for</w:t></w:r><w:r><w:t> </w:t></w:r><w:r><w:t>n'est pas évident, nous proposons l'exemple d'une quantification d'histogramme. Nous souhaitons compter le nombre d'éléments d'une matrice dont la valeur est comprise entre 0 et 0.1, entre 0.1 et 0.2, entre 0.2 et 0.3...et entre 0.9 et 1. De nouveau, nous proposons une version avec boucle</w:t></w:r><w:r><w:t> </w:t></w:r><w:r><w:rPr><w:b/><w:rFonts w:cs="monospace"/></w:rPr><w:t>for</w:t></w:r><w:r><w:t> </w:t></w:r><w:r><w:t>et une version sans. Prenez le temps de bien comprendre les deux versions :</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="code"/></w:pPr><w:r><w:t><![CDATA[M = rand(800, 600);

Histogramme = zeros(1, 10);

tic
for i = 1:size(M, 1)
    for j = 1:size(M, 2)
        valeur = floor(M(i, j)*10);  % pour obtenir un indice entre 0 et 9
        indice = valeur+1;  % les indices en Matlab commencent à 1
        Histogramme(indice) = Histogramme(indice) + 1;
    end
end
toc]]></w:t></w:r></w:p><w:p><w:pPr><w:sectPr/></w:pPr></w:p><w:p><w:pPr><w:pStyle w:val="code"/></w:pPr><w:r><w:t><![CDATA[M = rand(800, 600);

tic
M = repmat(M(:), 1, 10);
intervalles1 = 0:0.1:0.9;
intervalles2 = 0.1:0.1:1;

% Pas besoin d'initialiser Histogramme car la variable est remplie en une fois
Histogramme = sum(M >= intervalles1 & M < intervalles2); 
toc]]></w:t></w:r></w:p><w:p><w:pPr><w:sectPr/></w:pPr></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t>Le symbole </w:t></w:r><w:r><w:rPr><w:b/><w:rFonts w:cs="monospace"/></w:rPr><w:t>&amp;</w:t></w:r><w:r><w:t> désigne ici le ET logique. De la même façon, on peut écrire un OU logique avec le symbole </w:t></w:r><w:r><w:rPr><w:b/><w:rFonts w:cs="monospace"/></w:rPr><w:t>|</w:t></w:r><w:r><w:t>. Dupliquer les matrices ou vecteurs pour éviter les boucles finit par avoir ses limites en temps avec l'augmentation des calculs.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t></w:t></w:r></w:p><w:p><mc:AlternateContent xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"><mc:Choice Requires="R2018b"><w:pPr><w:pStyle w:val="heading2"/><w:jc w:val="left"/></w:pPr></mc:Choice><mc:Fallback><w:pPr><w:pStyle w:val="heading"/><w:jc w:val="left"/></w:pPr></mc:Fallback></mc:AlternateContent><w:r><w:t>6.2) Utilisation de while et if</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t></w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t>Nous illustrons rapidement l'utilisation de </w:t></w:r><w:r><w:rPr><w:b/><w:rFonts w:cs="monospace"/></w:rPr><w:t>while</w:t></w:r><w:r><w:t> et </w:t></w:r><w:r><w:rPr><w:b/><w:rFonts w:cs="monospace"/></w:rPr><w:t>if</w:t></w:r><w:r><w:t> pour chercher à déterminer si un nombre </w:t></w:r><w:r><w:rPr><w:b/><w:rFonts w:cs="monospace"/></w:rPr><w:t>n</w:t></w:r><w:r><w:t> est premier ou non en calculant le reste de la division euclidienne de tous les nombres de 2 à racine carrée (</w:t></w:r><w:r><w:rPr><w:b/><w:rFonts w:cs="monospace"/></w:rPr><w:t>sqrt</w:t></w:r><w:r><w:t>) de </w:t></w:r><w:r><w:rPr><w:b/><w:rFonts w:cs="monospace"/></w:rPr><w:t>n</w:t></w:r><w:r><w:t> et en déclarant que le nombre n'est pas premier si l'un de ces restes est nul. En Matlab, on peut écrire :</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="code"/></w:pPr><w:r><w:t><![CDATA[n=983;

primalite = 1;
indice = 2;
while indice <= sqrt(n) && primalite
    if mod(n, indice) == 0
        primalite = 0;
    end
    indice = indice + 1;
end

primalite]]></w:t></w:r></w:p><w:p><w:pPr><w:sectPr/></w:pPr></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t>Au même titre que le test d'égalité se faisait avec "</w:t></w:r><w:r><w:rPr><w:b/><w:rFonts w:cs="monospace"/></w:rPr><w:t>==</w:t></w:r><w:r><w:t>" (2 fois le symbole), les tests pour les ET et OU logiques suivent la même règle : "</w:t></w:r><w:r><w:rPr><w:b/><w:rFonts w:cs="monospace"/></w:rPr><w:t>&amp;&amp;</w:t></w:r><w:r><w:t>" et "</w:t></w:r><w:r><w:rPr><w:b/><w:rFonts w:cs="monospace"/></w:rPr><w:t>||</w:t></w:r><w:r><w:t>".</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t></w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="title"/><w:jc w:val="left"/></w:pPr><w:r><w:t>7) Affichage de courbes</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t></w:t></w:r></w:p><w:p><mc:AlternateContent xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"><mc:Choice Requires="R2018b"><w:pPr><w:pStyle w:val="heading2"/><w:jc w:val="left"/></w:pPr></mc:Choice><mc:Fallback><w:pPr><w:pStyle w:val="heading"/><w:jc w:val="left"/></w:pPr></mc:Fallback></mc:AlternateContent><w:r><w:t>7.1) Plot de </w:t></w:r><w:r><w:rPr><w:b/></w:rPr><w:t>ℝ </w:t></w:r><w:r><w:t>dans </w:t></w:r><w:r><w:rPr><w:b/></w:rPr><w:t>ℝ </w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:rPr><w:b/></w:rPr><w:t></w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t>Il est possible de tracer des courbes avec la fonction </w:t></w:r><w:r><w:rPr><w:b/><w:rFonts w:cs="monospace"/></w:rPr><w:t>plot</w:t></w:r><w:r><w:t>. Commençons par un exemple simple :</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="code"/></w:pPr><w:r><w:t><![CDATA[X = [3, 5, 7, 8, 11, 15];
Y = [3, 4, -5, 6, 1, 10];
plot(X, Y);]]></w:t></w:r></w:p><w:p><w:pPr><w:sectPr/></w:pPr></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t>Pour ajouter un titre à la figure, on peut faire :</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="code"/></w:pPr><w:r><w:t><![CDATA[plot(X, Y);
title('Tracé de Y en fonction de X');]]></w:t></w:r></w:p><w:p><w:pPr><w:sectPr/></w:pPr></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t>On peut également ajouter du texte le long des axes :</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="code"/></w:pPr><w:r><w:t><![CDATA[plot(X, Y);
title('Tracé de Y en fonction de X');
xlabel('Nom de l''axe des abscisses');
ylabel('Nom de l''axe des ordonnées');]]></w:t></w:r></w:p><w:p><w:pPr><w:sectPr/></w:pPr></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t>Mais aussi des légendes dans le cas où plusieurs courbes sont superposées sur le même graphique : </w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="code"/></w:pPr><w:r><w:t><![CDATA[plot(X, Y);
hold on
plot(X, -0.5*Y)
hold off
title('Tracé de Y et 0.5*Y en fonction de X');
xlabel('Nom de l''axe des abscisses');
ylabel('Nom de l''axe des ordonnées');
legend('courbe de Y','courbe de -0.5*Y')]]></w:t></w:r></w:p><w:p><w:pPr><w:sectPr/></w:pPr></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t>On peut préciser la couleur du tracé et aussi si l'on veut des symboles simplement sans relier les points  :</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="code"/></w:pPr><w:r><w:t><![CDATA[plot(X, Y,'r*');]]></w:t></w:r></w:p><w:p><w:pPr><w:sectPr/></w:pPr></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t>On peut regrouper plusieurs figures avec la fonction </w:t></w:r><w:r><w:rPr><w:b/><w:rFonts w:cs="monospace"/></w:rPr><w:t>subplot</w:t></w:r><w:r><w:t> : on indique d'abord le nombre de lignes </w:t></w:r><w:r><w:rPr><w:b/><w:rFonts w:cs="monospace"/></w:rPr><w:t>n</w:t></w:r><w:r><w:t>, le nombre de colonnes </w:t></w:r><w:r><w:rPr><w:b/><w:rFonts w:cs="monospace"/></w:rPr><w:t>m</w:t></w:r><w:r><w:t> et enfin l'indice (entre 1 et n*m) de la figure que l'on dessine. On peut choisir pour chaque sous-figure d'ajouter un titre et des étiquettes sur les axes ou non :</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="code"/></w:pPr><w:r><w:t><![CDATA[subplot(2,2,1);
plot(X, Y);
title('Titre de la sous-figure 1')

subplot(2,2,2);
plot(X, Y,'r');
xlabel('Axe X de la figure 2')

subplot(2,2,3);
plot(X, Y,'*');
ylabel('Axe Y de la figure 3')

subplot(2,2,4);
plot(X, Y,'r*');
title('Titre de la sous-figure 4')
xlabel('Axe X de la figure 4')
ylabel('Axe Y de la figure 4')]]></w:t></w:r></w:p><w:p><w:pPr><w:sectPr/></w:pPr></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t></w:t></w:r></w:p><w:p><mc:AlternateContent xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"><mc:Choice Requires="R2018b"><w:pPr><w:pStyle w:val="heading2"/><w:jc w:val="left"/></w:pPr></mc:Choice><mc:Fallback><w:pPr><w:pStyle w:val="heading"/><w:jc w:val="left"/></w:pPr></mc:Fallback></mc:AlternateContent><w:r><w:t>7.2) plot de </w:t></w:r><w:r><w:rPr><w:b/></w:rPr><w:t>ℝ</w:t></w:r><w:r><w:t>² dans </w:t></w:r><w:r><w:rPr><w:b/></w:rPr><w:t>ℝ</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t></w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t>La fonction </w:t></w:r><w:r><w:rPr><w:b/><w:rFonts w:cs="monospace"/></w:rPr><w:t>contour(X,Y,Z)</w:t></w:r><w:r><w:t> permet un affichage en lignes de niveaux. De nouveau, nous illustrons son utilisation au travers d'un exemple. Nous commençons par définir deux axes </w:t></w:r><w:r><w:rPr><w:b/><w:rFonts w:cs="monospace"/></w:rPr><w:t>X</w:t></w:r><w:r><w:t> et </w:t></w:r><w:r><w:rPr><w:b/><w:rFonts w:cs="monospace"/></w:rPr><w:t>Y</w:t></w:r><w:r><w:t> gradués à chaque unité de -20 à 20 : </w:t></w:r><w:r><w:rPr><w:b/><w:rFonts w:cs="monospace"/></w:rPr><w:t>X</w:t></w:r><w:r><w:t> et </w:t></w:r><w:r><w:rPr><w:b/><w:rFonts w:cs="monospace"/></w:rPr><w:t>Y</w:t></w:r><w:r><w:t> sont donc deux vecteurs de taille 41. Une valeur z est attribuée à chaque couple (x, y). Pour pouvoir utiliser </w:t></w:r><w:r><w:rPr><w:b/><w:rFonts w:cs="monospace"/></w:rPr><w:t>contour</w:t></w:r><w:r><w:t>, il faut stocker tous les valeurs z dans une matrice </w:t></w:r><w:r><w:rPr><w:b/><w:rFonts w:cs="monospace"/></w:rPr><w:t>Z</w:t></w:r><w:r><w:t> (qui seront donc de taille 41x41).</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t>Pour avoir une certaine régularité dans les lignes de niveaux de l'exemple ci-dessous, nous calculons chaque valeur de </w:t></w:r><w:r><w:rPr><w:b/><w:rFonts w:cs="monospace"/></w:rPr><w:t>Z</w:t></w:r><w:r><w:t> à partir des valeurs voisines et perturbons la valeur d'une quantité comprise entre -0.5 et 0.5 (</w:t></w:r><w:r><w:rPr><w:b/><w:rFonts w:cs="monospace"/></w:rPr><w:t>rand</w:t></w:r><w:r><w:t>-0.5). Il aurait été possible de simplement assigner une valeur aléatoire, mais les lignes de niveaux auraient alors été plus difficiles à visualiser.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="code"/></w:pPr><w:r><w:t><![CDATA[close all % Pour fermer le subplot

X = -20:20;
Y = -20:20;
Z = zeros(41,41);
for i = 2:41
    for j = 2:41
        Z(i,j) = rand - 0.5 + (Z(i-1,j-1)+Z(i-1,j)+Z(i,j-1))/3;
    end
end
contour(X, Y, Z);]]></w:t></w:r></w:p><w:p><w:pPr><w:sectPr/></w:pPr></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t>Enfin, la documentation Matlab détaille et illustre tous les types d'affichage possibles (on y retrouve notamment des histogrammes et des courbes en 3D) sur la page suivante :</w:t></w:r><w:r><w:t> </w:t></w:r><w:hyperlink w:docLocation="https://www.mathworks.com/help/matlab/creating_plots/types-of-matlab-plots.html."><w:r><w:t>https://www.mathworks.com/help/matlab/creating_plots/types-of-matlab-plots.html.</w:t></w:r></w:hyperlink></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t></w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="title"/><w:jc w:val="left"/></w:pPr><w:r><w:t>8) Lecture et affichage d'images</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t></w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t>En Matlab, les images sont représentées par des matrices dont chaque élément représente le niveau de gris (pour des images en noir et blanc) ou la couleur (pour des images en couleur) d'un pixel de l'image. Pour des images en niveaux de gris, les matrices associées sont bidimensionnelles et sont de taille (</w:t></w:r><w:r><w:rPr><w:b/><w:rFonts w:cs="monospace"/></w:rPr><w:t>nb_lignes, nb_colonnes</w:t></w:r><w:r><w:t>). Pour des images en couleur, les matrices associées sont tridimensionnelles et sont de taille (</w:t></w:r><w:r><w:rPr><w:b/><w:rFonts w:cs="monospace"/></w:rPr><w:t>nb_lignes, nb_colonnes, 3</w:t></w:r><w:r><w:t>) : les 3 canaux de la troisième dimension permettent d'encoder le niveau de couleur (rouge, vert ou bleu) du pixel (codage RGB).</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t>Les valeurs sont prises entre 0 et 255 inclus.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t>À titre d'exemples :</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="ListParagraph"/><w:numPr><w:numId w:val="1"/></w:numPr><w:jc w:val="left"/></w:pPr><w:r><w:t>(r = 255, g = 0, b = 0) donne du rouge vif</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="ListParagraph"/><w:numPr><w:numId w:val="1"/></w:numPr><w:jc w:val="left"/></w:pPr><w:r><w:t>(r = 255, g = 255, b = 0) donne du jaune vif</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="ListParagraph"/><w:numPr><w:numId w:val="1"/></w:numPr><w:jc w:val="left"/></w:pPr><w:r><w:t>(r = 128, g = 128, b = 128) donne du gris</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="ListParagraph"/><w:numPr><w:numId w:val="1"/></w:numPr><w:jc w:val="left"/></w:pPr><w:r><w:t>pour des images en niveaux de gris, 0 correspond au noir et 255 au blanc</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t>Vous pouvez sélectionner une couleur et obtenir son code RGB sur le site suivant :</w:t></w:r><w:r><w:t> </w:t></w:r><w:hyperlink w:docLocation="https://htmlcolorcodes.com/fr/selecteur-de-couleur/"><w:r><w:t>https://htmlcolorcodes.com/fr/selecteur-de-couleur/</w:t></w:r></w:hyperlink></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t>De manière générale, les fonctions d'affichage seront déjà écrites dans les TP de probabilités et statistiques. Nous présentons donc rapidement les principales fonctions.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t>Matlab dispose de quelques images internes. La lecture d'une image se fait avec la fonction </w:t></w:r><w:r><w:rPr><w:b/><w:rFonts w:cs="monospace"/></w:rPr><w:t>imread</w:t></w:r><w:r><w:t> :</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="code"/></w:pPr><w:r><w:t><![CDATA[I = imread('moon.tif');
imagesc(I);]]></w:t></w:r></w:p><w:p><w:pPr><w:sectPr/></w:pPr></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t>Pour l'affichage des images en niveaux de gris, Matlab utilise une palette de couleurs. Par défaut, il s'agit de couleurs allant du jaune/vert pour les niveaux de gris élevés au bleu pour les niveaux de gris faibles. Il est possible de modifier la palette de couleurs avec l'instruction </w:t></w:r><w:r><w:rPr><w:b/><w:rFonts w:cs="monospace"/></w:rPr><w:t>colormap</w:t></w:r><w:r><w:t> comme suit :</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="code"/></w:pPr><w:r><w:t><![CDATA[imagesc(I)
colormap gray;]]></w:t></w:r></w:p><w:p><w:pPr><w:sectPr/></w:pPr></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t>Il se peut que les proportions ne soient pas bien conservées lors de l'affichage, c'est pourquoi il faut agir sur les axes avec l'instruction </w:t></w:r><w:r><w:rPr><w:b/><w:rFonts w:cs="monospace"/></w:rPr><w:t>axis</w:t></w:r><w:r><w:t> (pour conserver le ratio et aussi enlever les nombres sur les axes) :</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="code"/></w:pPr><w:r><w:t><![CDATA[imagesc(I)
colormap gray;
axis equal off; % axis image est presque équivalent à axis equal]]></w:t></w:r></w:p><w:p><w:pPr><w:sectPr/></w:pPr></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t>Ci-dessous, un exemple d'image en couleur. Notez que la matrice est affichée canal par canal : </w:t></w:r><w:r><w:rPr><w:b/><w:rFonts w:cs="monospace"/></w:rPr><w:t>I(:,:,1)</w:t></w:r><w:r><w:t> correspond au canal rouge, </w:t></w:r><w:r><w:rPr><w:b/><w:rFonts w:cs="monospace"/></w:rPr><w:t>I(:,:,2)</w:t></w:r><w:r><w:t> au canal vert et </w:t></w:r><w:r><w:rPr><w:b/><w:rFonts w:cs="monospace"/></w:rPr><w:t>I(:,:,3)</w:t></w:r><w:r><w:t> au canal bleu par convention. Lorsque l'on affiche des images en couleur, il n'y a pas de colormap à gérer.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="code"/></w:pPr><w:r><w:t><![CDATA[I = imread('peppers.png');  % ";" pour ne pas afficher la matrice en sortie
imagesc(I);
axis image off;]]></w:t></w:r></w:p><w:p><w:pPr><w:sectPr/></w:pPr></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t></w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="title"/><w:jc w:val="left"/></w:pPr><w:r><w:t>9) Exercice applicatif</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t></w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t>Le script suivant lit une image en niveaux de gris, la stocke dans la matrice bidimensionnelle</w:t></w:r><w:r><w:t> </w:t></w:r><w:r><w:rPr><w:b/><w:rFonts w:cs="monospace"/></w:rPr><w:t>image_originale</w:t></w:r><w:r><w:rPr><w:rFonts w:cs="monospace"/></w:rPr><w:t> </w:t></w:r><w:r><w:t>et l’affiche. </w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="code"/></w:pPr><w:r><w:t><![CDATA[% Lecture et affichage de l'image originale :
image_originale = imread('image_originale.png');
imagesc(image_originale);
axis image;
colormap gray;
title('Image originale (1024x1024)')]]></w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t>Les niveaux de gris des pixels de cette image sont obtenus après traversée d’une mosaïque de filtres colorés, appelée </w:t></w:r><w:r><w:t>matrice de Bayer (voir ci-dessous), qui est placée devant le récepteur photosensible des appareils photographiques.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t></w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="center"/></w:pPr><w:customXml w:element="image"><w:customXmlPr><w:attr w:name="height" w:val="182"/><w:attr w:name="width" w:val="182"/><w:attr w:name="relationshipId" w:val="rId3"/></w:customXmlPr></w:customXml></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="center"/></w:pPr><w:r><w:t>Matrice de Bayer</w:t></w:r></w:p><w:p><w:pPr><w:sectPr/></w:pPr></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="center"/></w:pPr><w:r><w:t></w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t>Ecrivez la fonction </w:t></w:r><w:r><w:rPr><w:b/><w:rFonts w:cs="monospace"/></w:rPr><w:t>ecriture_RVB </w:t></w:r><w:r><w:t>dans le fichier </w:t></w:r><w:r><w:rPr><w:b/></w:rPr><w:t>ecriture_RVB.m</w:t></w:r><w:r><w:t> que vous devez au préalable créer. L’en-tête de cette fonction s’écrit :</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="center"/></w:pPr><w:r><w:rPr><w:b/><w:rFonts w:cs="monospace"/></w:rPr><w:t>function image_RVB = ecriture_RVB(image_originale)</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t>Elle doit créer une matrice</w:t></w:r><w:r><w:t> </w:t></w:r><w:r><w:rPr><w:b/><w:rFonts w:cs="monospace"/></w:rPr><w:t>image_RVB</w:t></w:r><w:r><w:rPr><w:rFonts w:cs="monospace"/></w:rPr><w:t> </w:t></w:r><w:r><w:t>à 3 dimensions contenant deux fois moins de lignes et deux fois moins de colonnes que</w:t></w:r><w:r><w:t> </w:t></w:r><w:r><w:rPr><w:rFonts w:cs="monospace"/></w:rPr><w:t>image_originale</w:t></w:r><w:r><w:t>. Chaque pixel de</w:t></w:r><w:r><w:t> </w:t></w:r><w:r><w:rPr><w:rFonts w:cs="monospace"/></w:rPr><w:t>image_RVB</w:t></w:r><w:r><w:rPr><w:rFonts w:cs="monospace"/></w:rPr><w:t> </w:t></w:r><w:r><w:t>correspond à un ensemble de quatre pixels de </w:t></w:r><w:r><w:rPr><w:b/><w:rFonts w:cs="monospace"/></w:rPr><w:t>image_originale</w:t></w:r><w:r><w:rPr><w:rFonts w:cs="monospace"/></w:rPr><w:t> </w:t></w:r><w:r><w:t>: </w:t></w:r><w:r><w:rPr><w:b/><w:rFonts w:cs="monospace"/></w:rPr><w:t>V1</w:t></w:r><w:r><w:t>, </w:t></w:r><w:r><w:rPr><w:b/><w:rFonts w:cs="monospace"/></w:rPr><w:t>R</w:t></w:r><w:r><w:t>, </w:t></w:r><w:r><w:rPr><w:b/><w:rFonts w:cs="monospace"/></w:rPr><w:t>V2</w:t></w:r><w:r><w:t>, </w:t></w:r><w:r><w:rPr><w:b/><w:rFonts w:cs="monospace"/></w:rPr><w:t>B</w:t></w:r><w:r><w:t>. Les valeurs </w:t></w:r><w:r><w:rPr><w:b/><w:rFonts w:cs="monospace"/></w:rPr><w:t>R</w:t></w:r><w:r><w:t> et </w:t></w:r><w:r><w:rPr><w:b/><w:rFonts w:cs="monospace"/></w:rPr><w:t>B</w:t></w:r><w:r><w:t> sont recopiées telles quelles dans les canaux rouge et bleu de</w:t></w:r><w:r><w:t> </w:t></w:r><w:r><w:rPr><w:b/><w:rFonts w:cs="monospace"/></w:rPr><w:t>image_RVB</w:t></w:r><w:r><w:t>. En revanche, la valeur dans le canal vert est égale à la moyenne des valeurs </w:t></w:r><w:r><w:rPr><w:b/><w:rFonts w:cs="monospace"/></w:rPr><w:t>V1</w:t></w:r><w:r><w:t> </w:t></w:r><w:r><w:t>et </w:t></w:r><w:r><w:rPr><w:b/><w:rFonts w:cs="monospace"/></w:rPr><w:t>V2</w:t></w:r><w:r><w:t>. Pour concaténer des matrices suivant la 3ème dimension, on pourra utiliser la fonction </w:t></w:r><w:r><w:rPr><w:b/><w:rFonts w:cs="monospace"/></w:rPr><w:t>cat(3,canal_R,canal_V,canal_B)</w:t></w:r><w:r><w:t>. Une fois la fonction terminée, lancez le script suivant pour vérifier le résultat.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="code"/></w:pPr><w:r><w:t><![CDATA[% Conversion des entiers non signés en doubles :
image_originale = double(image_originale);

% Ecriture de image_RVB :
image_RVB = ecriture_RVB(image_originale);

% Affichage de l'image RVB convertie en entiers non signes :
imagesc(uint8(image_RVB));
axis image;
title('Image convertie en RVB (512x512x3)')]]></w:t></w:r></w:p><w:p><w:pPr><w:sectPr/></w:pPr></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t>On voit bien que les dimensions de l'image ont été divisées par 2. On remarquera que l'on a passé l'image en type double pour faire des opérations à virgule pour le canal vert, puisque la plupart du temps les images sont codées en entiers non signés sur 8 bits (valeurs entre 0 et 255). On repasse l'image dans ce format avant de faire l'affichage final.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t></w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="title"/><w:jc w:val="left"/></w:pPr><w:r><w:t>10) Erreurs classiques</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t></w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t>On parvient rarement à écrire un code sans erreur du premier coup. Au travers de messages d'erreur, Matlab indique généralement le type d'erreur rencontré (problème de dimension, variable non définie...) et la ligne à laquelle se produit l'erreur.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t>Dans cette partie, nous vous fournissons plusieurs instructions Matlab qui renvoient une erreur lorsqu'elles sont lancées. À vous de comprendre d'où proviennent les erreurs et de les corriger.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:rPr><w:b/></w:rPr><w:t>Il faut enlever le symbole "</w:t></w:r><w:r><w:rPr><w:b/><w:rFonts w:cs="monospace"/></w:rPr><w:t>%</w:t></w:r><w:r><w:rPr><w:b/></w:rPr><w:t>" en début de ligne pour décommenter le code.</w:t></w:r></w:p><w:p><w:pPr><w:sectPr/></w:pPr></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t>A- On souhaite créer une matrice de taille 320 x 240 avec des nombres aléatoires compris entre 0 et 256</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="code"/></w:pPr><w:r><w:t><![CDATA[% Matrice = 256*rand(320, 240));]]></w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t>Vous remarquerez dans la petite barre de droite un tiret orange pour signaler un warning et un tiret rouge pour signaler une erreur. Lorsque que vous avez décommenté, un tiret rouge est apparu. </w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:rPr><w:b/></w:rPr><w:t>S'il y a une erreur dans n'importe quelle partie d'un fichier, toutes les lignes de codes présentes dans le fichier ne fonctionneront pas</w:t></w:r><w:r><w:t> (cela est dû à l'erreur qui arrête la compilation du fichier).</w:t></w:r></w:p><w:p><w:pPr><w:sectPr/></w:pPr></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t>B- On souhaite ajouter à chaque colonne de A sa colonne suivante. La dernière colonne de A reste inchangée.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="code"/></w:pPr><w:r><w:t><![CDATA[% Matrice(:, 1:end-1) = Matrice(:, 1:end-1) + matrice(:, 1:end);]]></w:t></w:r></w:p><w:p><w:pPr><w:sectPr/></w:pPr></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t>C- On souhaite ensuite centrer les valeurs en retirant la valeur moyenne de la matrice obtenue.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="code"/></w:pPr><w:r><w:t><![CDATA[% Matrice = Matrice - repmat(mean(meen(Matrice)), 320, 240);]]></w:t></w:r></w:p><w:p><w:pPr><w:sectPr/></w:pPr></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t>D- On souhaite mettre à 0 tous les coefficients négatifs de la matrice.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="code"/></w:pPr><w:r><w:t><![CDATA[% (Matrice < 0) = 0;]]></w:t></w:r></w:p><w:p><w:pPr><w:sectPr/></w:pPr></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t></w:t></w:r></w:p></w:body></w:document>