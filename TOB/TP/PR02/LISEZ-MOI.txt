Nom       : Ragot
Prénom    : Cyrian
Groupe TP : K

Les « ... » indiquent les endroits à compléter.

=====[ Temps passé ]============================================================

Ces informations de temps sont demandées à titre indicatif et ne sont pas
prises en compte dans la notation du projet.


* Temps passé sur la V1 : 20 heures 0 minutes
* Temps passé sur la V2 : 2 heures 0 minutes

Pour la V2 on ne tiendra pas compte du temps passé sur la V1.


=====[ Questions ]==============================================================

--------------------------------------------------------------------------------
Pourquoi l'exception OperationInterditeException ne peut pas être définie
comme vérifiée par le compilateur ?
--------------------------------------------------------------------------------

Cette exception est non vérifiée par le compilateur car il n'est pas possible de prévoir si 
l'utilisateur va choisir de tricher ou non. De plus, on ne sait pas à l'avance quelles stratégies
seront employées pour les joueurs qui s'affrontent (on ne sait pas si il y auras un tricheur ou non).
C'est une exception liée à une mauvaise utilisation (le fait ce tricher) du programme donc elle est non vérifiée.


--------------------------------------------------------------------------------
Expliquer ce qu'il faut faire pour ajouter un nouveau niveau de jeu, par
exemple la stratégie lente (C13).  Pour plus de précision, on numérotera
les étapes à faire.
--------------------------------------------------------------------------------

Pour ajouter un niveau de jeu :
1. Créer une nouvelle classe (dans le sous-package "strategie")
qui hérite de la classe abstraite "Strategie" ou "StrategieTrichable" selon si
on souhaite une simple stratégie ou une stratégie avec laquelle on peut tricher.
La nouvelle stratégie devra implémenter "StrategieScanner" si elle nécessite
une entrée utilisateur.
2. On importe "allumettes.Jeu" dans cette classe.
3. Dans le cas de la stratégie lente qui n'est pas trichable, on implémente le contructeur 
de la nouvelle stratégie, renvoyant le nom choisit pour celle-ci au constructeur de la super classe.
4. On implémente la méthode "choixPrise" qui définit le fonctionnement de la stratégie.
5. On peut maintenant instancier cette stratégie et l'ajouter dans la hashmap "STRATEGIES" de "Jouer"
de la même manière qu'on l'a fait pour les autres stratégies (voir méthode "ajouterStrategie" de "Jouer").


--------------------------------------------------------------------------------
Expliquer ce qui permet, dans votre conception, de changer dynamiquement
(en cours d'exécution du programme) la stratégie d'un joueur (C14).
--------------------------------------------------------------------------------

Un joueur possède la stratégie comme attribut qui peut être modifié pendant
l'exécution du programme via la méthode "setStrategie" de "Joueur". De plus,
à chaque appel de "getPrise" le joueur utilise la stratégie actuelle qu'il possède
comme attribut. Si l'attribut "strategie" a changé, cet appel utilisera la nouvelle stratégie.


=====[ Explications ]===========================================================

--------------------------------------------------------------------------------
Donner ici les explications supplémentaires utiles à la compréhension du
travail rendu.
--------------------------------------------------------------------------------

1. Au final, j'ai abandonné la classe abstraite StrategieTrichable malgré que 
j'ai plus de similitudes.

2. J'ai abandonné le joueurRegister selon vos conseils.

3. L'interface "StrategieScanner" permet de donner à une stratégie la capacité de
demander une entrée utilisateur via un seul Scanner static instancié par cette interface, il
suffit qu'une stratégie implémente cette interface pour utiliser le scanner. Cela permet aussi
plus d'extensibilité.

4. J'ai passé le nombre d'allumettes initiales du jeu et le nombre de joueurs comme paramètres constants
de la classe "Jouer" pour permettre de les changer plus simplement que d'utiliser "en dur" des nombres ou
des variables locales.

5. J'ai quelques similitudes dans les fichiers d'évaluation automatique, j'en ai corrigé quelques unes qui n'étaient pas géniales
mais il ne me semble pas que les similitudes restantes reflètent un réel problème de structuration du code.

--------------------------------------------------------------------------------
