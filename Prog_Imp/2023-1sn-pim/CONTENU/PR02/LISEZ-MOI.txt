% Compte-rendu minimal du mini-projet SDA : LCA et TH
% Auteur : RAGOT Cyrian
% Groupe de TP : K


**Consigne :** Vous devez écrire vos réponse à la place des ... en laissant
une ligne vide avant et deux après votre réponse.

**Remarque :** Ce document utilise le langage Markdown. On peut en engendrer
une version PDF en faisant par exemple :

~~~
pandoc --toc -N -o LISEZ-MOI.pdf LISEZ-MOI.txt
~~~


# Exercice 1

## Question 1.4

**Indiquer les inconvénients/avantages d'une implantation par listes chaînées
d'une SDA.**

Avantage : implantation relativement simple à comprendre et mettre en oeuvre
Inconvénients : la récursivité prends pas mal de mémoire, on est obligé de parcourir toute la 
liste chaînée dans le pire cas pour toutes les opérations. Peut être aussi le fait qu'il faille
penser à détruire la sda après utilisation. 


# Évaluation expérimentale.

## Performance comparée de LCA et TH

Indiquer ici les résultats obtenus.

Voici quelques résultats avec le temps utilisateur pour chaque programme :
Borne: 10, Taille: 1000 => LCA: 0.004s, TH: 0.031s
Borne: 10, Taille: 100000 => LCA: 0.085s, TH: 2.856s
Borne: 100, Taille: 1000 => LCA: 0.079s, TH: 0.036s
Borne: 1000, Taille: 1000 => LCA: 11.793s, TH: 0.066s
Borne: 1000, Taille: 100000 => LCA: 11m35s, TH: 3.671s
Borne: 100000, Taille: 100000 => TH: 4m5s
Borne: 100000, Taille: 10000000 => TH: tourne trop longtemps (quasiment 2h) donc arrêté de force
Finalement, pour une borne faible (10) les LCA et les TH sont autant efficaces (les LCA sont même
légèrement meilleures) mais dès qu'on arrive à 100 en borne, les TH deviennent déjà bien meilleures
à taille d'échantillon fixé. C'est normal puisqu'on parcours plusieurs petites LCA avec les TH, à
la place d'une grande LCA dont les opérations sont coûteuses.


## Qualité du générateur aléatoire

Indiquer les conclusions quant à la qualité du générateur aléatoire.

Si on prends par exemple le résultat de borne=1000 et taille=100000. 
Le pire cas serait Min = 0 et Max = 100000 et le résultat obtenu est Min = 73 et Max = 130.
Ceci nous fait un ratio de 57/100000 = 0.057 %.
Notre générateur aléatoire est performant.


# Principales difficultés rencontrées

Indiquer ici les principales difficultés rencontrées lors de la réalisation de
ce projet et comment elles ont été surmontées ou contournées.

Pour l'exercice 1 j'avais écrit en itératif la plupart des prodécures/fonctions mais le premier 
test me soulevait mon erreur Cle_Absente_Exception lors de l'execution. Au final, en changeant 
et en écrivant tout de manière récursive je n'ai plus eu ce problème. C'était à cause de ma 
procédure Enregistrer mais je n'ai toujours pas compris pourquoi il me soulevait quand même cette
erreur.


# Informations complémentaires

Indiquer ici les informations qui pourraient aider à la compréhension du
travail réalisé.

Cette partie peut être vide.

J'ai corrigé sur l'exercice 1 le problème d'indentation normalement à toutes les lignes.
J'avais mal configuré mon neovim personnel.
La fonction de hachage utilisant la longueur des chaînes de caractères que j'ai 
implémentée renvoie la position 1 pour une chaîne de longueur d'un multiple de 11. On aurait pu 
décaler les indices renvoyés pour que la longueur de la chaîne de la clé soit exactement égale
à la position de la clé dans le tableau mais cela ne change pas grand chose, la vitesse de lecture
reste en principe la même (on a juste qu'une clé de longueur 11 est placée dans la LCA de position 0
dans le tableau par exemple, ce décalage ne change rien).
Pour ce qui est des programmes d'évaluation, on aurais pu optimiser plus les programmes (j'utilise quand même 3 boucles for) et on aurais pu utiliser la procédure Pour_Chaque mais comme ce n'est pas 
le but principal de l'exercice et que l'amélioration n'affecterait pas notre comparaison des
programmes avec LCA ou TH, je me suis permis de le laisser tel quel.


# Bilan personnel

Quel bilan personnel tirez-vous de ce mini-projet ?

Ce projet m'a bien aider à mieux comprendre les notions de pointeurs, et de généricité et 
leurs implantations en Ada. C'était des notions encore assez difficiles mais maintenant ça va.
Sinon j'ai trouvé intéressante l'implémentation des tables de hachage, qui est une notion que j'avais déjà utilisé en Java mais que je ne comprenais pas vraiment avant.

